---
interface WikiNode {
  id: string;
  term: string;
  category: string;
  summary: string;
}

interface WikiLink {
  source: string;
  target: string;
}

interface Props {
  nodes: WikiNode[];
  links: WikiLink[];
  currentWikiId?: string;
}

const { nodes, links, currentWikiId } = Astro.props;

const categoryColors: Record<string, string> = {
  database: '#3b82f6',
  java: '#f59e0b',
  spring: '#22c55e',
  architecture: '#8b5cf6',
  infra: '#06b6d4',
  general: '#6b7280',
};
---

<div class="wiki-graph-container">
  <div class="graph-bg">
    <div class="gradient-orb orb-1"></div>
    <div class="gradient-orb orb-2"></div>
    <div class="gradient-orb orb-3"></div>
  </div>
  <div class="particles" id="particles"></div>
  <div class="graph-controls">
    <button id="zoom-in" title="확대">+</button>
    <button id="zoom-out" title="축소">−</button>
    <button id="zoom-reset" title="초기화">⟲</button>
  </div>
  <div class="graph-legend">
    <span class="legend-item legend-hub">
      <svg width="14" height="14" viewBox="-10 -10 20 20">
        <polygon points="8,0 4,7 -4,7 -8,0 -4,-7 4,-7" fill="#6b7280" stroke="#fff" stroke-width="1.5"/>
      </svg>
      Hub
    </span>
    {Object.entries(categoryColors).map(([category, color]) => (
      <span class="legend-item">
        <span class="legend-dot" style={`background: ${color}`}></span>
        {category}
      </span>
    ))}
  </div>
  <svg id="wiki-graph"></svg>
  <div id="tooltip" class="graph-tooltip"></div>
</div>

<script
  id="graph-data"
  type="application/json"
  set:html={JSON.stringify({ nodes, links, currentWikiId, categoryColors })}
/>

<script>
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';

  // 정리할 리소스 저장
  let cleanupFns: (() => void)[] = [];

  function cleanup() {
    cleanupFns.forEach(fn => fn());
    cleanupFns = [];
  }

  function initGraph() {
    cleanup(); // 이전 인스턴스 정리

    const dataEl = document.getElementById('graph-data');
    if (!dataEl) return;

    const { nodes, links, currentWikiId, categoryColors } = JSON.parse(dataEl.textContent || '{}');

    const container = document.querySelector('.wiki-graph-container');
    if (!container) return;

    const svg = d3.select('#wiki-graph');
    const tooltip = d3.select('#tooltip');

    svg.selectAll('*').remove();

    const width = container.clientWidth;
    const height = Math.min(800, window.innerHeight * 0.7);

    svg.attr('width', width).attr('height', height);

    // 줌 기능
    const g = svg.append('g');
    const zoom = d3.zoom()
      .scaleExtent([0.3, 3])
      .on('zoom', (event: any) => {
        g.attr('transform', event.transform);
      });

    svg.call(zoom as any);

    // 줌 버튼
    const zoomInBtn = d3.select('#zoom-in');
    const zoomOutBtn = d3.select('#zoom-out');
    const zoomResetBtn = d3.select('#zoom-reset');

    zoomInBtn.on('click', () => svg.transition().duration(300).call(zoom.scaleBy as any, 1.3));
    zoomOutBtn.on('click', () => svg.transition().duration(300).call(zoom.scaleBy as any, 0.7));
    zoomResetBtn.on('click', () => svg.transition().duration(300).call(zoom.transform as any, d3.zoomIdentity));

    // 노드별 연결 수 계산
    const nodeDegree: Record<string, number> = {};
    nodes.forEach((n: any) => nodeDegree[n.id] = 0);
    links.forEach((l: any) => {
      const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
      const targetId = typeof l.target === 'object' ? l.target.id : l.target;
      nodeDegree[sourceId] = (nodeDegree[sourceId] || 0) + 1;
      nodeDegree[targetId] = (nodeDegree[targetId] || 0) + 1;
    });

    // 허브 노드 판별
    const hubThreshold = 3;
    nodes.forEach((d: any) => {
      d.degree = nodeDegree[d.id] || 0;
      d.isHub = d.degree >= hubThreshold;
    });

    // 노드 초기 위치
    nodes.forEach((d: any) => {
      d.x = width / 2 + (Math.random() - 0.5) * 200;
      d.y = height / 2 + (Math.random() - 0.5) * 200;
    });

    // Force 시뮬레이션 (최적화: alphaDecay 증가)
    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links).id((d: any) => d.id).distance(100).strength(0.4))
      .force('charge', d3.forceManyBody().strength(-300))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(40))
      .force('x', d3.forceX(width / 2).strength(0.05))
      .force('y', d3.forceY(height / 2).strength(0.05))
      .alphaDecay(0.028)
      .velocityDecay(0.35);

    // 링크 그라데이션
    const defs = svg.append('defs');
    const gradient = defs.append('linearGradient')
      .attr('id', 'link-gradient')
      .attr('gradientUnits', 'userSpaceOnUse');
    gradient.append('stop').attr('offset', '0%').attr('stop-color', '#60a5fa');
    gradient.append('stop').attr('offset', '50%').attr('stop-color', '#a78bfa');
    gradient.append('stop').attr('offset', '100%').attr('stop-color', '#60a5fa');

    // 링크 그리기
    const link = g.append('g')
      .attr('class', 'links')
      .selectAll('line')
      .data(links)
      .join('line')
      .attr('stroke', 'url(#link-gradient)')
      .attr('stroke-width', 1.5)
      .attr('stroke-opacity', 0.4);

    // 노드 그룹
    const node = g.append('g')
      .attr('class', 'nodes')
      .selectAll('g')
      .data(nodes)
      .join('g')
      .attr('class', 'node')
      .call(d3.drag()
        .on('start', (event: any, d: any) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        })
        .on('drag', (event: any, d: any) => {
          d.fx = event.x;
          d.fy = event.y;
        })
        .on('end', (event: any, d: any) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        }) as any);

    // 육각형 path
    const hexagonPath = (size: number) => {
      const angles = [0, 60, 120, 180, 240, 300].map(a => a * Math.PI / 180);
      return angles.map((angle, i) => {
        const x = size * Math.cos(angle);
        const y = size * Math.sin(angle);
        return (i === 0 ? 'M' : 'L') + x + ',' + y;
      }).join('') + 'Z';
    };

    // 노드 모양
    node.each(function(d: any) {
      const el = d3.select(this);
      const size = d.id === currentWikiId ? 22 : (d.isHub ? 18 : 14);
      const color = categoryColors[d.category] || '#6b7280';
      const strokeColor = d.id === currentWikiId ? '#1f2937' : '#fff';
      const strokeWidth = d.id === currentWikiId ? 3 : 1.5;

      if (d.isHub) {
        el.append('path')
          .attr('class', 'hub-node')
          .attr('d', hexagonPath(size))
          .attr('fill', color)
          .attr('stroke', strokeColor)
          .attr('stroke-width', strokeWidth)
          .style('cursor', 'pointer');
      } else {
        el.append('circle')
          .attr('r', size)
          .attr('fill', color)
          .attr('stroke', strokeColor)
          .attr('stroke-width', strokeWidth)
          .style('cursor', 'pointer');
      }
    });

    // 호버 효과
    node.on('mouseover', (event: any, d: any) => {
      tooltip
        .style('opacity', 1)
        .html(`<strong>${d.term}</strong><br/><span>${d.summary}</span>`)
        .style('left', (event.pageX + 10) + 'px')
        .style('top', (event.pageY - 10) + 'px');

      const connectedIds = new Set<string>();
      links.forEach((l: any) => {
        if (l.source.id === d.id || l.source === d.id) connectedIds.add(typeof l.target === 'object' ? l.target.id : l.target);
        if (l.target.id === d.id || l.target === d.id) connectedIds.add(typeof l.source === 'object' ? l.source.id : l.source);
      });
      connectedIds.add(d.id);

      node.style('opacity', (n: any) => connectedIds.has(n.id) ? 1 : 0.15);
      link.style('opacity', (l: any) => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        return sourceId === d.id || targetId === d.id ? 0.8 : 0.05;
      });
    })
    .on('mouseout', () => {
      tooltip.style('opacity', 0);
      node.style('opacity', 1);
      link.style('opacity', 0.4);
    })
    .on('click', (_: any, d: any) => {
      window.location.href = `/wiki/${d.id}`;
    });

    // 시뮬레이션 업데이트
    simulation.on('tick', () => {
      link
        .attr('x1', (d: any) => d.source.x)
        .attr('y1', (d: any) => d.source.y)
        .attr('x2', (d: any) => d.target.x)
        .attr('y2', (d: any) => d.target.y);

      node.attr('transform', (d: any) => `translate(${d.x},${d.y})`);
    });

    // 시뮬레이션 시작
    simulation.alpha(1).restart();

    // Intersection Observer로 보일 때만 애니메이션
    let isVisible = true;
    let animationInterval: number | null = null;

    const visibilityObserver = new IntersectionObserver((entries) => {
      isVisible = entries[0].isIntersecting;
      if (isVisible && !animationInterval) {
        startAnimations();
      } else if (!isVisible && animationInterval) {
        stopAnimations();
      }
    }, { threshold: 0.1 });

    visibilityObserver.observe(container);
    cleanupFns.push(() => visibilityObserver.disconnect());

    function startAnimations() {
      // 주기적 움직임 (5초마다)
      animationInterval = window.setInterval(() => {
        if (!isVisible) return;
        const randomNode = nodes[Math.floor(Math.random() * nodes.length)];
        if (randomNode && !randomNode.fx) {
          randomNode.vx += (Math.random() - 0.5) * 1.5;
          randomNode.vy += (Math.random() - 0.5) * 1.5;
          simulation.alpha(0.08).restart();
        }
      }, 5000);
    }

    function stopAnimations() {
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
      }
    }

    startAnimations();
    cleanupFns.push(stopAnimations);

    // 시뮬레이션 종료 시 부드럽게 재시작
    simulation.on('end', () => {
      if (isVisible) {
        setTimeout(() => simulation.alpha(0.02).restart(), 3000);
      }
    });

    // 파티클 생성 (15개로 감소)
    const particlesContainer = document.getElementById('particles');
    if (particlesContainer) {
      particlesContainer.innerHTML = '';
      for (let i = 0; i < 15; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.top = Math.random() * 100 + '%';
        particle.style.animationDelay = Math.random() * 5 + 's';
        particle.style.animationDuration = (4 + Math.random() * 4) + 's';
        particlesContainer.appendChild(particle);
      }
    }

    // 정리 함수 등록
    cleanupFns.push(() => {
      simulation.stop();
      zoomInBtn.on('click', null);
      zoomOutBtn.on('click', null);
      zoomResetBtn.on('click', null);
    });
  }

  // 초기화
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGraph);
  } else {
    initGraph();
  }

  // View Transitions 대응
  document.addEventListener('astro:page-load', initGraph);
</script>

<style>
  .wiki-graph-container {
    position: relative;
    width: 100%;
    background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #0f0f1a 100%);
    border-radius: 20px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    overflow: hidden;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
  }

  .graph-bg {
    position: absolute;
    inset: 0;
    overflow: hidden;
    z-index: 0;
    will-change: transform;
  }

  .gradient-orb {
    position: absolute;
    border-radius: 50%;
    filter: blur(60px);
    opacity: 0.4;
    animation: float 25s ease-in-out infinite;
    will-change: transform;
  }

  .orb-1 {
    width: 350px;
    height: 350px;
    background: radial-gradient(circle, rgba(99, 102, 241, 0.35) 0%, transparent 70%);
    top: -100px;
    left: -100px;
  }

  .orb-2 {
    width: 300px;
    height: 300px;
    background: radial-gradient(circle, rgba(168, 85, 247, 0.3) 0%, transparent 70%);
    top: 50%;
    right: -80px;
    animation-delay: -8s;
  }

  .orb-3 {
    width: 250px;
    height: 250px;
    background: radial-gradient(circle, rgba(34, 211, 238, 0.25) 0%, transparent 70%);
    bottom: -50px;
    left: 30%;
    animation-delay: -16s;
  }

  @keyframes float {
    0%, 100% { transform: translate(0, 0) scale(1); }
    33% { transform: translate(20px, -20px) scale(1.02); }
    66% { transform: translate(-15px, 15px) scale(0.98); }
  }

  .particles {
    position: absolute;
    inset: 0;
    z-index: 1;
    pointer-events: none;
  }

  :global(.particle) {
    position: absolute;
    width: 2px;
    height: 2px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    animation: sparkle 5s ease-in-out infinite;
    will-change: transform, opacity;
  }

  @keyframes sparkle {
    0%, 100% { opacity: 0; transform: translateY(0) scale(0); }
    50% { opacity: 0.8; transform: translateY(-15px) scale(1); }
  }

  #wiki-graph {
    display: block;
    width: 100%;
    height: 70vh;
    min-height: 500px;
    max-height: 800px;
    position: relative;
    z-index: 2;
  }

  .graph-controls {
    position: absolute;
    top: 16px;
    right: 16px;
    display: flex;
    gap: 6px;
    z-index: 10;
  }

  .graph-controls button {
    width: 36px;
    height: 36px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border-radius: 10px;
    cursor: pointer;
    font-size: 18px;
    color: rgba(255, 255, 255, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s, transform 0.2s;
  }

  .graph-controls button:hover {
    background: rgba(255, 255, 255, 0.15);
    transform: translateY(-1px);
  }

  .graph-legend {
    position: absolute;
    top: 16px;
    left: 16px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    z-index: 10;
    background: rgba(255, 255, 255, 0.06);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    padding: 10px 14px;
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    font-size: 11px;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
    color: rgba(255, 255, 255, 0.8);
    font-weight: 500;
  }

  .legend-hub {
    padding-right: 8px;
    margin-right: 4px;
    border-right: 1px solid rgba(255, 255, 255, 0.15);
  }

  .legend-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
  }

  .graph-tooltip {
    position: absolute;
    padding: 12px 16px;
    background: rgba(15, 15, 30, 0.95);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    color: #fff;
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 13px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s;
    max-width: 260px;
    z-index: 100;
    line-height: 1.5;
  }

  .graph-tooltip strong {
    display: block;
    margin-bottom: 4px;
    color: #a78bfa;
    font-size: 14px;
  }

  .graph-tooltip span {
    color: rgba(255, 255, 255, 0.75);
  }

  :global(.nodes .node) {
    cursor: pointer;
  }

  :global(.nodes .node:hover circle),
  :global(.nodes .node:hover path) {
    filter: brightness(1.15);
  }

  @media (max-width: 768px) {
    .graph-legend {
      font-size: 10px;
      padding: 8px 10px;
      gap: 8px;
    }
    .legend-dot {
      width: 6px;
      height: 6px;
    }
  }
</style>
