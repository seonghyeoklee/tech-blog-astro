---
interface WikiNode {
  id: string;
  term: string;
  category: string;
  summary: string;
}

interface WikiLink {
  source: string;
  target: string;
}

interface Props {
  nodes: WikiNode[];
  links: WikiLink[];
  currentWikiId?: string;
  fullscreen?: boolean;
}

const { nodes, links, currentWikiId, fullscreen = false } = Astro.props;

const categoryColors: Record<string, string> = {
  database: '#3b82f6',
  java: '#f59e0b',
  spring: '#22c55e',
  architecture: '#8b5cf6',
  infra: '#06b6d4',
  general: '#6b7280',
};
---

<div class={`wiki-graph-container ${fullscreen ? 'fullscreen' : ''}`}>
  <div class="graph-controls">
    <button id="zoom-in" title="확대">+</button>
    <button id="zoom-out" title="축소">−</button>
    <button id="zoom-reset" title="초기화">⟲</button>
  </div>
  <div class="graph-legend">
    <span class="legend-item legend-hub">
      <svg width="14" height="14" viewBox="-10 -10 20 20">
        <polygon points="8,0 4,7 -4,7 -8,0 -4,-7 4,-7" fill="#6b7280" stroke="#fff" stroke-width="1.5"/>
      </svg>
      Hub
    </span>
    {Object.entries(categoryColors).map(([category, color]) => (
      <span class="legend-item">
        <span class="legend-dot" style={`background: ${color}`}></span>
        {category}
      </span>
    ))}
  </div>
  <svg id="wiki-graph"></svg>
  <div id="tooltip" class="graph-tooltip"></div>
</div>

<script
  id="graph-data"
  type="application/json"
  set:html={JSON.stringify({ nodes, links, currentWikiId, categoryColors, fullscreen })}
/>

<script>
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';

  let cleanupFns: (() => void)[] = [];

  function cleanup() {
    cleanupFns.forEach(fn => fn());
    cleanupFns = [];
  }

  function initGraph() {
    cleanup();

    const dataEl = document.getElementById('graph-data');
    if (!dataEl) return;

    const { nodes, links, currentWikiId, categoryColors, fullscreen } = JSON.parse(dataEl.textContent || '{}');

    const container = document.querySelector('.wiki-graph-container');
    if (!container) return;

    const svg = d3.select('#wiki-graph');
    const tooltip = d3.select('#tooltip');

    svg.selectAll('*').remove();

    const width = container.clientWidth;
    const height = fullscreen ? container.clientHeight : Math.max(600, window.innerHeight - 180);

    svg.attr('width', width).attr('height', height);

    // 줌 기능
    const g = svg.append('g');
    const zoom = d3.zoom()
      .scaleExtent([0.3, 3])
      .on('zoom', (event: any) => {
        g.attr('transform', event.transform);
      });

    svg.call(zoom as any);

    // 줌 버튼
    const zoomInBtn = d3.select('#zoom-in');
    const zoomOutBtn = d3.select('#zoom-out');
    const zoomResetBtn = d3.select('#zoom-reset');

    zoomInBtn.on('click', () => svg.transition().duration(300).call(zoom.scaleBy as any, 1.3));
    zoomOutBtn.on('click', () => svg.transition().duration(300).call(zoom.scaleBy as any, 0.7));
    zoomResetBtn.on('click', () => svg.transition().duration(300).call(zoom.transform as any, d3.zoomIdentity));

    // 노드별 연결 수 계산
    const nodeDegree: Record<string, number> = {};
    nodes.forEach((n: any) => nodeDegree[n.id] = 0);
    links.forEach((l: any) => {
      const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
      const targetId = typeof l.target === 'object' ? l.target.id : l.target;
      nodeDegree[sourceId] = (nodeDegree[sourceId] || 0) + 1;
      nodeDegree[targetId] = (nodeDegree[targetId] || 0) + 1;
    });

    // 허브 노드 판별
    const hubThreshold = 3;
    nodes.forEach((d: any) => {
      d.degree = nodeDegree[d.id] || 0;
      d.isHub = d.degree >= hubThreshold;
    });

    // 노드 초기 위치 - 더 넓게 분산
    nodes.forEach((d: any) => {
      const angle = Math.random() * Math.PI * 2;
      const radius = 100 + Math.random() * 200;
      d.x = width / 2 + Math.cos(angle) * radius;
      d.y = height / 2 + Math.sin(angle) * radius;
    });

    // Force 시뮬레이션 - 더 부드러운 움직임
    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links).id((d: any) => d.id).distance(120).strength(0.3))
      .force('charge', d3.forceManyBody().strength(-400))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(50))
      .force('x', d3.forceX(width / 2).strength(0.03))
      .force('y', d3.forceY(height / 2).strength(0.03))
      .alphaDecay(0.015)
      .velocityDecay(0.4);

    // 링크 글로우 효과
    const defs = svg.append('defs');

    // 글로우 필터
    const glow = defs.append('filter')
      .attr('id', 'glow')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
    glow.append('feGaussianBlur')
      .attr('stdDeviation', '2')
      .attr('result', 'coloredBlur');
    const glowMerge = glow.append('feMerge');
    glowMerge.append('feMergeNode').attr('in', 'coloredBlur');
    glowMerge.append('feMergeNode').attr('in', 'SourceGraphic');

    // 링크 그리기
    const link = g.append('g')
      .attr('class', 'links')
      .selectAll('line')
      .data(links)
      .join('line')
      .attr('stroke', 'rgba(167, 139, 250, 0.4)')
      .attr('stroke-width', 1.5);

    // 노드 그룹
    const node = g.append('g')
      .attr('class', 'nodes')
      .selectAll('g')
      .data(nodes)
      .join('g')
      .attr('class', 'node')
      .call(d3.drag()
        .on('start', (event: any, d: any) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        })
        .on('drag', (event: any, d: any) => {
          d.fx = event.x;
          d.fy = event.y;
        })
        .on('end', (event: any, d: any) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        }) as any);

    // 육각형 path
    const hexagonPath = (size: number) => {
      const angles = [0, 60, 120, 180, 240, 300].map(a => a * Math.PI / 180);
      return angles.map((angle, i) => {
        const x = size * Math.cos(angle);
        const y = size * Math.sin(angle);
        return (i === 0 ? 'M' : 'L') + x + ',' + y;
      }).join('') + 'Z';
    };

    // 노드 모양 - 허브 노드 더 크게
    node.each(function(d: any) {
      const el = d3.select(this);
      const size = d.id === currentWikiId ? 28 : (d.isHub ? 24 : 12);
      const color = categoryColors[d.category] || '#6b7280';
      const strokeColor = d.id === currentWikiId ? '#fff' : 'rgba(255,255,255,0.8)';
      const strokeWidth = d.id === currentWikiId ? 3 : (d.isHub ? 2 : 1.5);

      if (d.isHub) {
        el.append('path')
          .attr('class', 'hub-node')
          .attr('d', hexagonPath(size))
          .attr('fill', color)
          .attr('stroke', strokeColor)
          .attr('stroke-width', strokeWidth)
          .attr('filter', 'url(#glow)')
          .style('cursor', 'pointer');
      } else {
        el.append('circle')
          .attr('r', size)
          .attr('fill', color)
          .attr('stroke', strokeColor)
          .attr('stroke-width', strokeWidth)
          .attr('filter', 'url(#glow)')
          .style('cursor', 'pointer');
      }
    });

    // 노드 텍스트
    node.append('text')
      .text((d: any) => d.term.length > 12 ? d.term.slice(0, 12) + '...' : d.term)
      .attr('x', 0)
      .attr('y', (d: any) => d.isHub ? 38 : 24)
      .attr('text-anchor', 'middle')
      .attr('font-size', (d: any) => d.isHub ? '12px' : '10px')
      .attr('fill', 'rgba(255, 255, 255, 0.9)')
      .attr('font-weight', (d: any) => (d.id === currentWikiId || d.isHub) ? '700' : '400')
      .style('text-shadow', '0 0 10px rgba(0,0,0,0.9)');

    // 호버 효과
    node.on('mouseover', (event: any, d: any) => {
      tooltip
        .style('opacity', 1)
        .html(`<strong>${d.term}</strong><br/><span>${d.summary}</span>`)
        .style('left', (event.pageX + 10) + 'px')
        .style('top', (event.pageY - 10) + 'px');

      const connectedIds = new Set<string>();
      links.forEach((l: any) => {
        if (l.source.id === d.id || l.source === d.id) connectedIds.add(typeof l.target === 'object' ? l.target.id : l.target);
        if (l.target.id === d.id || l.target === d.id) connectedIds.add(typeof l.source === 'object' ? l.source.id : l.source);
      });
      connectedIds.add(d.id);

      node.style('opacity', (n: any) => connectedIds.has(n.id) ? 1 : 0.15);
      link.style('opacity', (l: any) => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        return sourceId === d.id || targetId === d.id ? 0.8 : 0.05;
      });
    })
    .on('mouseout', () => {
      tooltip.style('opacity', 0);
      node.style('opacity', 1);
      link.style('opacity', 1);
    })
    .on('click', (_: any, d: any) => {
      window.location.href = `/wiki/${d.id}`;
    });

    // 시뮬레이션 업데이트
    simulation.on('tick', () => {
      link
        .attr('x1', (d: any) => d.source.x)
        .attr('y1', (d: any) => d.source.y)
        .attr('x2', (d: any) => d.target.x)
        .attr('y2', (d: any) => d.target.y);

      node.attr('transform', (d: any) => `translate(${d.x},${d.y})`);
    });

    // 시뮬레이션 시작
    simulation.alpha(1).restart();

    // 지속적인 부드러운 움직임 (우주 느낌)
    let isVisible = true;
    let driftInterval: number | null = null;

    const visibilityObserver = new IntersectionObserver((entries) => {
      isVisible = entries[0].isIntersecting;
      if (isVisible && !driftInterval) {
        startDrift();
      } else if (!isVisible && driftInterval) {
        stopDrift();
      }
    }, { threshold: 0.1 });

    visibilityObserver.observe(container);
    cleanupFns.push(() => visibilityObserver.disconnect());

    function startDrift() {
      // 지속적인 미세 움직임 - 우주에 떠있는 느낌
      driftInterval = window.setInterval(() => {
        if (!isVisible) return;

        // 여러 노드에 부드러운 힘 적용
        const numNodesToMove = Math.floor(Math.random() * 3) + 1;
        for (let i = 0; i < numNodesToMove; i++) {
          const randomNode = nodes[Math.floor(Math.random() * nodes.length)];
          if (randomNode && !randomNode.fx) {
            randomNode.vx += (Math.random() - 0.5) * 0.8;
            randomNode.vy += (Math.random() - 0.5) * 0.8;
          }
        }
        simulation.alpha(0.03).restart();
      }, 2000);
    }

    function stopDrift() {
      if (driftInterval) {
        clearInterval(driftInterval);
        driftInterval = null;
      }
    }

    startDrift();
    cleanupFns.push(stopDrift);

    // 시뮬레이션 종료 시 재시작
    simulation.on('end', () => {
      if (isVisible) {
        setTimeout(() => simulation.alpha(0.02).restart(), 1000);
      }
    });

    // 정리 함수 등록
    cleanupFns.push(() => {
      simulation.stop();
      zoomInBtn.on('click', null);
      zoomOutBtn.on('click', null);
      zoomResetBtn.on('click', null);
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGraph);
  } else {
    initGraph();
  }

  document.addEventListener('astro:page-load', initGraph);
</script>

<style>
  .wiki-graph-container {
    position: relative;
    width: 100%;
    background: transparent;
    overflow: hidden;
  }

  .wiki-graph-container.fullscreen {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  #wiki-graph {
    display: block;
    width: 100%;
    height: 100%;
    position: relative;
    z-index: 2;
  }

  .wiki-graph-container:not(.fullscreen) #wiki-graph {
    height: calc(100vh - 180px);
    min-height: 600px;
  }

  .graph-controls {
    position: absolute;
    bottom: 20px;
    right: 20px;
    display: flex;
    gap: 6px;
    z-index: 10;
  }

  .graph-controls button {
    width: 40px;
    height: 40px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 12px;
    cursor: pointer;
    font-size: 20px;
    color: rgba(255, 255, 255, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
  }

  .graph-controls button:hover {
    background: rgba(255, 255, 255, 0.15);
    border-color: rgba(255, 255, 255, 0.3);
    transform: translateY(-2px);
  }

  .graph-legend {
    position: absolute;
    bottom: 20px;
    left: 20px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    z-index: 10;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 12px 16px;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 12px;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    color: rgba(255, 255, 255, 0.8);
    font-weight: 500;
  }

  .legend-hub {
    padding-right: 10px;
    margin-right: 6px;
    border-right: 1px solid rgba(255, 255, 255, 0.2);
  }

  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    box-shadow: 0 0 6px currentColor;
  }

  .graph-tooltip {
    position: fixed;
    padding: 14px 18px;
    background: rgba(10, 10, 20, 0.95);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    color: #fff;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    font-size: 13px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    max-width: 280px;
    z-index: 1000;
    line-height: 1.6;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  }

  .graph-tooltip strong {
    display: block;
    margin-bottom: 6px;
    color: #a78bfa;
    font-size: 15px;
  }

  .graph-tooltip span {
    color: rgba(255, 255, 255, 0.7);
  }

  :global(.nodes .node) {
    cursor: pointer;
    transition: opacity 0.3s;
  }

  :global(.nodes .node:hover circle),
  :global(.nodes .node:hover path) {
    filter: brightness(1.3) url(#glow);
  }

  :global(.links line) {
    transition: opacity 0.3s;
  }

  @media (max-width: 768px) {
    .graph-legend {
      font-size: 10px;
      padding: 10px 12px;
      gap: 8px;
      bottom: 70px;
    }
    .legend-dot {
      width: 8px;
      height: 8px;
    }
    .graph-controls {
      bottom: 15px;
      right: 15px;
    }
    .graph-controls button {
      width: 36px;
      height: 36px;
      font-size: 18px;
    }
  }
</style>
