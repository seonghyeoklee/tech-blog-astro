---
title: '프로세스 스케줄링 - CPU는 어떻게 작업을 분배하는가'
description: 'CPU 스케줄링 알고리즘을 은행 창구, 응급실 비유로 쉽게 이해합니다'
pubDate: 'Dec 15 2024'
tags: ['CS', 'OS']
---

크롬 탭을 100개 열어도 컴퓨터는 멈추지 않습니다. 동시에 음악을 듣고, 코드를 작성하고, 빌드도 돌립니다. CPU는 하나인데 어떻게 이게 가능할까요? 바로 프로세스 스케줄링 덕분입니다.

## 왜 스케줄링이 필요한가

노트북의 CPU 코어가 4개라고 가정하겠습니다. 하지만 지금 실행 중인 프로세스는 200개가 넘습니다. 4개 코어로 200개 프로세스를 어떻게 처리할까요?

운영체제는 각 프로세스에 CPU를 아주 짧은 시간(보통 10~100ms)만 할당합니다. 프로세스 A에 20ms, 프로세스 B에 20ms, 이런 식으로 빠르게 교체합니다. 사람 눈에는 동시에 실행되는 것처럼 보입니다.

이때 "누구에게 먼저 CPU를 줄까?"를 결정하는 게 스케줄링입니다.

## 스케줄링 알고리즘

### FCFS (First Come First Served)

은행 창구를 떠올려보세요. 먼저 온 사람부터 순서대로 처리합니다. 가장 단순한 방식입니다.

```
대기열: [A, B, C, D]
A: 10분 소요
B: 1분 소요
C: 1분 소요
D: 1분 소요

→ B, C, D는 A가 끝날 때까지 10분 기다림
```

문제가 보이나요? A가 복잡한 업무로 10분이 걸리면, 1분이면 끝날 B, C, D가 10분을 기다려야 합니다. 평균 대기 시간이 길어집니다.

컴퓨터로 치면 무거운 프로그램 하나가 CPU를 독점하면 나머지가 전부 느려집니다.

### SJF (Shortest Job First)

응급실을 떠올려보세요. 환자가 도착한 순서가 아니라 치료 시간이 짧은 순서대로 처리합니다.

```
대기열: [A(10분), B(1분), C(1분), D(1분)]

→ 처리 순서: B → C → D → A
→ 평균 대기 시간 감소
```

B는 0분 대기, C는 1분 대기, D는 2분 대기, A는 3분 대기합니다. 평균 대기 시간이 FCFS보다 훨씬 짧습니다.

하지만 문제가 있습니다. A는 영원히 실행 안 될 수도 있습니다. 1분짜리 작업이 계속 들어오면 10분짜리 A는 계속 밀립니다. 이걸 **기아(Starvation)** 문제라고 합니다.

### Round Robin

놀이기구를 떠올려보세요. 한 번 타면 3분 후 내려와서 다시 줄을 섭니다. 모든 사람이 공평하게 기회를 얻습니다.

```
대기열: [A(10분), B(1분), C(1분)]
할당 시간: 2분

1회전: A(2분) → B(1분 완료) → C(1분 완료)
2회전: A(2분)
3회전: A(2분)
4회전: A(2분)
5회전: A(2분 완료)
```

누구도 오래 기다리지 않습니다. A도 최소한 2분마다 한 번씩 실행됩니다. 대부분의 운영체제가 이 방식을 기본으로 사용합니다.

할당 시간을 **타임 슬라이스(Time Slice)** 또는 **퀀텀(Quantum)**이라고 합니다. 리눅스는 보통 6~100ms입니다.

## 실제 CPU 스케줄링

실제 운영체제는 훨씬 복잡합니다. 우선순위, CPU 사용 패턴, I/O 대기 등을 모두 고려합니다.

리눅스의 CFS(Completely Fair Scheduler)는 모든 프로세스가 공평하게 CPU를 사용하도록 보장합니다. 적게 실행된 프로세스에 더 높은 우선순위를 줍니다.

### 우선순위 스케줄링

모든 프로세스가 동등하지는 않습니다. 시스템 프로세스는 사용자 프로세스보다 우선순위가 높습니다.

```
우선순위 1 (높음): 시스템 프로세스
우선순위 2: 포그라운드 프로그램 (지금 사용 중인 앱)
우선순위 3 (낮음): 백그라운드 작업
```

크롬을 쓰는 동안 백그라운드 업데이트가 느린 이유입니다. 우선순위가 낮아서 CPU를 적게 받습니다.

## CPU 바운드 vs I/O 바운드

스케줄링을 이해하려면 프로세스 특성을 알아야 합니다.

**CPU 바운드 작업**
- CPU 계산이 많은 작업
- 예: 동영상 인코딩, 데이터 분석, 암호화
- CPU를 계속 사용하고 싶어함

**I/O 바운드 작업**
- 디스크 읽기, 네트워크 요청 등 대기가 많은 작업
- 예: 웹 서버, DB 조회, 파일 복사
- CPU를 조금 쓰다가 I/O 대기

운영체제는 I/O 바운드 작업에 약간 더 높은 우선순위를 줍니다. 어차피 금방 I/O 대기 상태로 들어가서 CPU를 반납하기 때문입니다. 전체 시스템 응답성이 좋아집니다.

## 실무와의 연결

[프로세스와 스레드](/blog/process-and-thread)에서 스레드 풀 이야기를 했습니다. 스레드 풀 크기를 정할 때 이 개념이 필요합니다.

**CPU 바운드 작업**
```java
// CPU 코어 수 + 1 정도가 적당
int threadPoolSize = Runtime.getRuntime().availableProcessors() + 1;
```

스레드가 많아봐야 컨텍스트 스위칭만 늘어납니다. CPU는 하나인데 스레드만 100개면 계속 교체만 합니다.

**I/O 바운드 작업**
```java
// 코어 수보다 훨씬 많이
int threadPoolSize = Runtime.getRuntime().availableProcessors() * 2;
// 또는 더 많이 (50~200)
```

DB 조회나 API 호출은 대부분 대기입니다. 스레드가 많아야 CPU를 효율적으로 사용합니다. 한 스레드가 I/O 대기할 때 다른 스레드가 CPU를 쓰면 됩니다.

실제 Tomcat 기본값은 200입니다. 웹 요청은 I/O 바운드이기 때문입니다.

## 컨텍스트 스위칭 비용

[컨텍스트 스위칭](/blog/context-switching)에서 다뤘듯이 프로세스 교체는 비용이 듭니다. 레지스터 저장, 메모리 맵 교체 등이 필요합니다.

타임 슬라이스가 너무 짧으면 어떻게 될까요?

```
타임 슬라이스: 1ms
컨텍스트 스위칭: 0.1ms

→ 10%가 교체 작업에 소모됨
```

타임 슬라이스가 너무 길면 응답성이 나빠집니다. 10초 타임 슬라이스면 마우스 클릭해도 최악의 경우 10초 기다려야 합니다.

그래서 대부분 운영체제는 10~100ms 사이 값을 사용합니다. 응답성과 효율성의 균형점입니다.

## 멀티코어 스케줄링

요즘 CPU는 코어가 여러 개입니다. 4코어 CPU면 진짜로 4개 프로세스를 동시 실행할 수 있습니다.

문제는 코어 간 작업 분배입니다.

```
코어 1: [A, B, C] → 바쁨
코어 2: [D] → 한가함
```

이런 상황이 생기면 운영체제가 작업을 재분배합니다. 이걸 **로드 밸런싱**이라고 합니다.

또 한 가지 고려사항이 있습니다. 프로세스를 다른 코어로 옮기면 캐시가 무효화됩니다. CPU 캐시는 코어마다 독립적이기 때문입니다.

그래서 운영체제는 가능하면 같은 프로세스를 같은 코어에 할당하려고 합니다. 이걸 **프로세서 친화성(Processor Affinity)**이라고 합니다.

## 정리

- CPU 스케줄링은 제한된 CPU를 여러 프로세스에 분배하는 방법입니다
- FCFS는 단순하지만 평균 대기 시간이 깁니다
- SJF는 효율적이지만 긴 작업이 굶을 수 있습니다
- Round Robin은 공평하고 응답성이 좋아서 가장 많이 씁니다
- CPU 바운드는 스레드를 적게, I/O 바운드는 많게 설정합니다
- 타임 슬라이스는 응답성과 효율성의 균형점입니다
