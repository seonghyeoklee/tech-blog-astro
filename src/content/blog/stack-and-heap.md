---
title: '스택과 힙 - 메모리 구조 이해하기'
description: '스택과 힙의 차이, 메모리 할당 방식, 그리고 왜 중요한지 정리했습니다'
pubDate: 'Jan 12 2025'
tags: ['CS', 'OS', 'Java']
series: 'backend-cs-fundamentals'
seriesOrder: 4
---

Java에서 StackOverflowError나 OutOfMemoryError를 만나본 적 있을 겁니다. 이 에러들을 이해하려면 스택과 힙이 어떻게 동작하는지 알아야 합니다. 메모리 구조를 이해하면 성능 튜닝이나 메모리 누수 디버깅에도 도움이 됩니다.

## 메모리 영역 구분

프로세스의 메모리는 크게 4가지 영역으로 나뉩니다.

```
높은 주소
┌─────────────────┐
│      Stack      │ ↓ 아래로 자람
├─────────────────┤
│                 │
│   (빈 공간)      │
│                 │
├─────────────────┤
│      Heap       │ ↑ 위로 자람
├─────────────────┤
│      Data       │
├─────────────────┤
│      Code       │
└─────────────────┘
낮은 주소
```

Code와 Data는 프로그램 시작 시 크기가 정해집니다. Stack과 Heap은 런타임에 동적으로 변합니다.

## 스택(Stack)

함수 호출과 지역 변수를 관리하는 영역입니다.

**특징**

- LIFO(Last In First Out) 구조
- 컴파일 타임에 크기가 결정되는 데이터 저장
- 매우 빠른 할당/해제 (포인터만 이동)
- 크기가 제한적 (보통 1MB ~ 8MB)
- 스레드마다 독립적인 스택

**저장되는 것**

- 함수의 지역 변수
- 함수 매개변수
- 리턴 주소
- 이전 스택 프레임 포인터

```java
public void methodA() {
    int x = 10;           // 스택에 저장
    int y = 20;           // 스택에 저장
    methodB(x, y);        // 리턴 주소 저장 후 methodB로 이동
}                         // 스택 프레임 제거

public void methodB(int a, int b) {
    int sum = a + b;      // 스택에 저장
}                         // 스택 프레임 제거
```

```
methodA 호출 시 스택:
┌─────────────────┐
│ y = 20          │
│ x = 10          │
│ 리턴 주소        │
│ 이전 프레임 포인터 │
└─────────────────┘ ← Stack Pointer

methodB 호출 시 스택:
┌─────────────────┐
│ sum = 30        │
│ b = 20          │
│ a = 10          │
│ 리턴 주소        │
│ 이전 프레임 포인터 │
├─────────────────┤
│ y = 20          │
│ x = 10          │
│ 리턴 주소        │
│ 이전 프레임 포인터 │
└─────────────────┘
```

함수가 끝나면 스택 포인터만 이동하면 됩니다. 메모리를 명시적으로 해제할 필요가 없습니다.

**StackOverflowError**

스택 공간이 부족하면 발생합니다. 주로 재귀 호출이 너무 깊어질 때 나타납니다.

```java
public void recursive() {
    recursive();  // 무한 재귀 → StackOverflowError
}
```

## 힙(Heap)

동적으로 할당되는 메모리 영역입니다.

**특징**

- 런타임에 크기가 결정되는 데이터 저장
- 명시적으로 할당/해제 (Java는 GC가 해제)
- 스택보다 할당/해제가 느림
- 크기가 상대적으로 큼
- 모든 스레드가 공유

**저장되는 것**

- new로 생성한 객체
- 배열
- 인스턴스 변수

```java
public void createUser() {
    User user = new User("kim");  // user 참조는 스택, User 객체는 힙
    int[] numbers = new int[100]; // numbers 참조는 스택, 배열은 힙
}
```

```
스택                        힙
┌─────────────┐           ┌─────────────────┐
│ numbers ────┼──────────→│ int[100]        │
│ user ───────┼──────┐    └─────────────────┘
└─────────────┘      │    ┌─────────────────┐
                     └───→│ User("kim")     │
                          └─────────────────┘
```

참조 변수(user, numbers)는 스택에 있고, 실제 객체는 힙에 있습니다.

**OutOfMemoryError**

힙 공간이 부족하면 발생합니다. 객체를 너무 많이 만들거나, 메모리 누수가 있을 때 나타납니다.

```java
List<byte[]> list = new ArrayList<>();
while (true) {
    list.add(new byte[1024 * 1024]);  // 계속 쌓임 → OOM
}
```

## 스택 vs 힙 비교

| 구분 | 스택 | 힙 |
|------|------|-----|
| 할당 속도 | 매우 빠름 | 상대적으로 느림 |
| 해제 | 자동 (함수 종료 시) | GC 또는 명시적 해제 |
| 크기 | 작음 (MB 단위) | 큼 (GB 단위 가능) |
| 접근 | 지역적, 스레드 안전 | 전역적, 동기화 필요 |
| 단편화 | 없음 | 발생 가능 |

## Java에서의 메모리 구조

Java는 힙 영역을 더 세분화합니다.

```
┌─────────────────────────────────────┐
│              JVM 힙                  │
├─────────────────────────────────────┤
│  Young Generation                   │
│  ┌───────┬───────┬───────┐         │
│  │ Eden  │  S0   │  S1   │         │
│  └───────┴───────┴───────┘         │
├─────────────────────────────────────┤
│  Old Generation                     │
│  ┌─────────────────────────────┐   │
│  │                             │   │
│  └─────────────────────────────┘   │
└─────────────────────────────────────┘
```

- **Eden**: 새 객체가 생성되는 곳
- **Survivor(S0, S1)**: Minor GC에서 살아남은 객체
- **Old**: 오래 살아남은 객체

대부분의 객체는 생성 직후 사라집니다. Young Generation에서 빠르게 정리하고, 오래 살아남은 객체만 Old로 이동합니다.

## 실무에서 고려할 점

**스택 크기 조절**

재귀가 깊어지는 알고리즘을 쓴다면 스택 크기를 늘릴 수 있습니다.

```bash
java -Xss2m MyApplication  # 스레드당 스택 크기 2MB
```

하지만 스택을 키우면 그만큼 스레드당 메모리 사용량이 늘어납니다. 스레드가 많은 서버에서는 신중해야 합니다.

**힙 크기 조절**

```bash
java -Xms512m -Xmx2g MyApplication
# -Xms: 초기 힙 크기
# -Xmx: 최대 힙 크기
```

힙이 작으면 GC가 자주 발생합니다. 너무 크면 GC 시간이 길어집니다. 애플리케이션 특성에 맞게 조절해야 합니다.

**객체 생성 최소화**

힙 할당은 스택보다 느리고 GC 부담도 있습니다. 불필요한 객체 생성을 줄이면 성능에 도움이 됩니다.

```java
// 매번 새 객체 생성
for (int i = 0; i < 1000000; i++) {
    String s = new String("hello");  // 비효율
}

// 재사용
String s = "hello";  // String pool 사용
for (int i = 0; i < 1000000; i++) {
    // s 재사용
}
```

## 정리

- 스택은 함수 호출과 지역 변수를 관리하고, 스레드마다 독립적입니다
- 힙은 동적 할당 객체를 저장하고, 모든 스레드가 공유합니다
- 스택은 빠르지만 크기가 작고, 힙은 느리지만 크기가 큽니다
- StackOverflowError는 스택 부족, OutOfMemoryError는 힙 부족입니다
- Java에서는 힙을 Young/Old로 나눠서 GC 효율을 높입니다
