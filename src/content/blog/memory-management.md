---
title: '가상 메모리와 페이징 - 효율적인 메모리 관리'
description: '가상 메모리의 개념, 페이징 기법, 페이지 교체 알고리즘, 그리고 실무에서 메모리 문제를 해결하는 방법을 정리했습니다'
pubDate: 'Jan 14 2025'
series: 'operating-system-fundamentals'
seriesOrder: 5
tags: ['OS', 'CS']
quiz:
  - question: "가상 메모리의 가장 큰 장점은?"
    options:
      - "프로그램 실행 속도 향상"
      - "물리 메모리보다 큰 프로그램 실행 가능"
      - "CPU 사용률 감소"
      - "메모리 단편화 제거"
    correctAnswer: 1
    explanation: "가상 메모리를 사용하면 물리 메모리 크기와 무관하게 큰 프로그램을 실행할 수 있습니다. 필요한 부분만 메모리에 올리고 나머지는 디스크에 저장합니다."

  - question: "페이지 테이블의 역할은?"
    options:
      - "프로세스 스케줄링"
      - "가상 주소를 물리 주소로 변환"
      - "메모리 할당"
      - "디스크 I/O 관리"
    correctAnswer: 1
    explanation: "페이지 테이블은 가상 주소와 물리 주소를 매핑하는 자료구조입니다. CPU가 가상 주소를 참조하면 페이지 테이블을 통해 실제 물리 주소를 찾습니다."

  - question: "페이지 폴트(Page Fault)가 발생하는 경우는?"
    options:
      - "메모리가 부족할 때"
      - "접근하려는 페이지가 물리 메모리에 없을 때"
      - "CPU 사용률이 높을 때"
      - "디스크가 가득 찼을 때"
    correctAnswer: 1
    explanation: "페이지 폴트는 CPU가 접근하려는 페이지가 현재 물리 메모리에 없을 때 발생합니다. 이 경우 OS가 디스크에서 해당 페이지를 메모리로 가져옵니다."

  - question: "LRU(Least Recently Used) 페이지 교체 알고리즘의 특징은?"
    options:
      - "가장 먼저 들어온 페이지를 교체"
      - "가장 오랫동안 사용되지 않은 페이지를 교체"
      - "참조 횟수가 가장 적은 페이지를 교체"
      - "랜덤하게 페이지를 선택"
    correctAnswer: 1
    explanation: "LRU는 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘입니다. 최근에 사용된 페이지는 다시 사용될 가능성이 높다는 지역성 원리를 활용합니다."

  - question: "TLB(Translation Lookaside Buffer)의 목적은?"
    options:
      - "디스크 접근 속도 향상"
      - "페이지 테이블 접근 속도 향상"
      - "CPU 캐시 크기 증가"
      - "메모리 용량 확장"
    correctAnswer: 1
    explanation: "TLB는 페이지 테이블 접근을 빠르게 하기 위한 캐시입니다. 자주 사용되는 가상 주소-물리 주소 매핑 정보를 저장해 주소 변환 속도를 높입니다."

  - question: "Thrashing(스래싱)이란?"
    options:
      - "CPU 사용률이 매우 높은 상태"
      - "페이지 폴트가 과도하게 발생하는 상태"
      - "메모리가 가득 찬 상태"
      - "디스크 I/O가 빠른 상태"
    correctAnswer: 1
    explanation: "스래싱은 페이지 폴트가 과도하게 발생해 실제 작업보다 페이지 교체에 더 많은 시간을 소비하는 상태입니다. 시스템 성능이 급격히 저하됩니다."

  - question: "페이징 기법의 주요 장점은?"
    options:
      - "메모리 접근 속도 향상"
      - "외부 단편화 제거"
      - "프로그램 실행 시간 단축"
      - "디스크 용량 절약"
    correctAnswer: 1
    explanation: "페이징은 메모리를 고정 크기 페이지로 나누어 관리하므로 외부 단편화가 발생하지 않습니다. 하지만 내부 단편화는 여전히 발생할 수 있습니다."

  - question: "Working Set(워킹 셋)이란?"
    options:
      - "프로세스가 사용 중인 전체 메모리"
      - "특정 시간 동안 참조된 페이지들의 집합"
      - "페이지 테이블의 크기"
      - "디스크에 저장된 페이지"
    correctAnswer: 1
    explanation: "워킹 셋은 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합입니다. 워킹 셋을 메모리에 유지하면 페이지 폴트를 줄일 수 있습니다."

  - question: "Demand Paging(요구 페이징)의 특징은?"
    options:
      - "프로그램 시작 시 모든 페이지를 메모리에 로드"
      - "필요한 페이지만 메모리에 로드"
      - "페이지를 미리 예측해서 로드"
      - "페이지를 랜덤하게 로드"
    correctAnswer: 1
    explanation: "Demand Paging은 페이지가 실제로 필요할 때만 메모리에 로드하는 방식입니다. 프로그램 시작 시간을 단축하고 메모리를 효율적으로 사용할 수 있습니다."

  - question: "페이지 크기가 클수록 발생하는 문제는?"
    options:
      - "외부 단편화 증가"
      - "내부 단편화 증가"
      - "페이지 폴트 증가"
      - "TLB 미스 증가"
    correctAnswer: 1
    explanation: "페이지 크기가 크면 페이지 내부에 사용되지 않는 공간이 많아져 내부 단편화가 증가합니다. 반면 페이지 테이블 크기는 줄어드는 장점이 있습니다."
---

프로세스가 실행되려면 메모리에 로드되어야 합니다. 하지만 물리 메모리는 제한적이고, 여러 프로세스가 동시에 실행됩니다. 운영체제는 어떻게 제한된 메모리를 효율적으로 관리할까요? 그 핵심이 **가상 메모리**와 **페이징**입니다.

## 메모리 관리의 필요성

### 문제 상황

```
물리 메모리: 8GB
실행 중인 프로그램들:
- Chrome: 2GB
- IntelliJ: 3GB
- Docker: 2GB
- MySQL: 1.5GB
총 필요 메모리: 8.5GB  ← 물리 메모리 초과!
```

**어떻게 8GB 메모리로 8.5GB가 필요한 프로그램들을 실행할까?**

→ **가상 메모리** 사용

## 가상 메모리란?

**실제 물리 메모리보다 큰 주소 공간을 제공하는 기술**입니다.

### 핵심 아이디어

1. 프로세스에게 **가상의 큰 메모리 공간** 제공
2. 실제로는 **필요한 부분만 물리 메모리**에 로드
3. 나머지는 **디스크(스왑 영역)**에 저장

### 가상 주소 vs 물리 주소

```
[가상 주소]                    [물리 주소]
프로세스 A: 0x00000000        RAM: 0x10000000
           ~ 0xFFFFFFFF             ~ 0x1FFFFFFF

프로세스 B: 0x00000000        디스크: Swap 영역
           ~ 0xFFFFFFFF
```

- **가상 주소**: 프로세스가 보는 주소 (논리적)
- **물리 주소**: 실제 RAM의 주소

**CPU가 가상 주소를 참조하면, MMU(Memory Management Unit)가 물리 주소로 변환**

## 페이징 (Paging)

가상 메모리를 구현하는 대표적인 방법이 **페이징**입니다.

### 페이징의 개념

**메모리를 고정 크기 블록으로 나누어 관리**

```
가상 메모리:                     물리 메모리:
+----------+                    +----------+
| Page 0   | -------\           | Frame 2  |
+----------+         \          +----------+
| Page 1   | ---------\-------> | Frame 0  |  ← Page 1
+----------+           \        +----------+
| Page 2   | -----------\-----> | Frame 3  |  ← Page 0
+----------+             \      +----------+
| Page 3   |              \---> | Frame 1  |  ← Page 2
+----------+                    +----------+
```

**용어:**
- **Page (페이지)**: 가상 메모리의 고정 크기 블록 (보통 4KB)
- **Frame (프레임)**: 물리 메모리의 고정 크기 블록 (페이지와 같은 크기)

### 페이지 테이블

**가상 주소와 물리 주소를 매핑하는 자료구조**

```
페이지 테이블 (Process A):
+-------+--------+-------+
| Page  | Frame  | Valid |
+-------+--------+-------+
|   0   |   2    |   1   |  ← 메모리에 있음
|   1   |   0    |   1   |
|   2   |   3    |   1   |
|   3   |   -    |   0   |  ← 디스크에 있음 (Page Fault)
+-------+--------+-------+
```

**Valid Bit:**
- `1`: 페이지가 물리 메모리에 있음
- `0`: 페이지가 디스크에 있음 (접근 시 Page Fault 발생)

### 주소 변환 과정

```
가상 주소 (32비트):
+------------------+----------------+
| Page Number (20) | Offset (12)    |
+------------------+----------------+

예: 0x00012ABC
  Page Number: 0x00012
  Offset: 0xABC

1. Page Number로 페이지 테이블 검색
2. Frame Number 찾기 (예: Frame 5)
3. Frame Number + Offset = 물리 주소
   → 0x00005ABC
```

## 페이지 폴트 (Page Fault)

**CPU가 접근하려는 페이지가 물리 메모리에 없을 때 발생하는 예외**

### 페이지 폴트 처리 과정

```
1. CPU가 가상 주소 접근
2. 페이지 테이블 확인 → Valid Bit = 0
3. Page Fault 발생 (Trap)
4. OS가 개입:
   - 디스크에서 해당 페이지 찾기
   - 물리 메모리에 빈 프레임 할당 (없으면 교체)
   - 페이지를 메모리로 로드
   - 페이지 테이블 업데이트 (Valid Bit = 1)
5. 중단된 명령어 재실행
```

**시간:**
- 메모리 접근: 100ns
- 디스크 접근: 10ms (100,000배 느림!)

**페이지 폴트가 자주 발생하면 성능 급격히 저하**

## 페이지 교체 알고리즘

물리 메모리가 가득 찼을 때, **어떤 페이지를 내보낼지 결정하는 알고리즘**

### 1. FIFO (First-In-First-Out)

**가장 먼저 들어온 페이지를 교체**

```
메모리 프레임: [1] [2] [3]

참조 순서: 1, 2, 3, 4, 1, 2, 5
         ↓  ↓  ↓  ↓     ↓  ↓
메모리:  1  1  1  4  4  4  5
            2  2  2  1  1  1
               3  3  3  2  2

Page Fault: 1, 2, 3, 4, 1, 2, 5 → 7번
```

**단점: 자주 사용되는 페이지도 교체될 수 있음**

### 2. LRU (Least Recently Used)

**가장 오랫동안 사용되지 않은 페이지를 교체**

```
메모리 프레임: [1] [2] [3]

참조 순서: 1, 2, 3, 4, 1, 2, 5
         ↓  ↓  ↓  ↓  ↓  ↓  ↓
메모리:  1  1  1  4  4  4  4
            2  2  2  1  1  5
               3  3  3  2  2

마지막 사용 시간 추적
Page Fault: 1, 2, 3, 4, 1(hit), 2(hit), 5 → 5번
```

**장점: 지역성 원리를 잘 활용 (최근 사용된 페이지는 다시 사용될 가능성 높음)**

### 3. LFU (Least Frequently Used)

**참조 횟수가 가장 적은 페이지를 교체**

```
참조 횟수 카운터 유지

페이지 1: 참조 5번
페이지 2: 참조 2번 ← 교체 대상
페이지 3: 참조 4번
```

### 4. Clock (Second Chance)

**LRU의 근사 알고리즘 (효율적)**

```
각 페이지에 Reference Bit 유지

    [1] → [1] → [1] → [1]
     ↑                 ↓
    [0] ← [0] ← [0] ← [1]

Reference Bit = 1: 최근 사용됨
Reference Bit = 0: 교체 가능
```

## TLB (Translation Lookaside Buffer)

**페이지 테이블 접근을 빠르게 하기 위한 캐시**

### 문제: 주소 변환 오버헤드

```
메모리 접근 1번 = 실제로는 2번 메모리 접근
1. 페이지 테이블 접근 (가상 → 물리 변환)
2. 실제 데이터 접근
```

### TLB 사용

```
CPU
 ↓
TLB (캐시) ←──┐
 │ Hit!       │ Miss
 ↓            ↓
데이터      페이지 테이블
           (메모리)
```

**TLB Hit (90-98%):**
- TLB에서 직접 물리 주소 찾음
- 시간: 1ns

**TLB Miss (2-10%):**
- 페이지 테이블 접근 필요
- 시간: 100ns

**효과적인 메모리 접근 시간:**
```
EAT = TLB Hit Time × TLB Hit Rate + (TLB Miss Time + Memory Access) × TLB Miss Rate
    = 1ns × 0.95 + (100ns + 100ns) × 0.05
    = 1ns + 10ns
    = 11ns
```

## 스래싱 (Thrashing)

**페이지 폴트가 과도하게 발생하는 현상**

### 발생 원인

```
프로세스가 너무 많이 실행 중
→ 각 프로세스의 워킹 셋이 메모리에 부족
→ 페이지 폴트 빈번
→ 페이지 교체 작업에 시간 소비
→ CPU 유휴
→ OS가 더 많은 프로세스 실행 (악순환)
```

### 스래싱 해결 방법

1. **프로세스 개수 줄이기**
2. **메모리 추가**
3. **워킹 셋 모델**: 프로세스의 워킹 셋 크기만큼 메모리 보장
4. **PFF (Page Fault Frequency)**: 페이지 폴트 빈도 모니터링

## 실무 예시

### 사례 1: Java 애플리케이션 OOM

```java
// 메모리 부족 발생
OutOfMemoryError: Java heap space

// 원인 분석
jstat -gcutil <pid> 1000
S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT
0.00  99.99  80.52  95.26  96.42  93.87   245    1.234    10   15.678

// 해결: 힙 메모리 증가
java -Xms2g -Xmx4g -XX:+UseG1GC MyApp
```

### 사례 2: Linux 메모리 모니터링

```bash
# 메모리 사용량 확인
free -h
              total        used        free      shared  buff/cache   available
Mem:           15Gi       8.2Gi       1.1Gi       324Mi       6.1Gi       6.5Gi
Swap:         2.0Gi       512Mi       1.5Gi

# Swap 사용 중 → 메모리 부족 신호
# 페이지 폴트 확인
vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0 524288 1155584 89216 6234112   0   10    50   200  500 1000 25  5 68  2  0
```

**si (swap in), so (swap out)이 크면 스래싱 의심**

### 사례 3: Docker 컨테이너 메모리 제한

```bash
# 메모리 제한 설정
docker run -m 512m --memory-swap 1g myapp

# OOM Killer 로그 확인
dmesg | grep -i "out of memory"
[12345.678] Out of memory: Kill process 1234 (java) score 950 or sacrifice child
```

## 정리

**가상 메모리와 페이징은 제한된 물리 메모리를 효율적으로 활용하는 핵심 기술**입니다.

**핵심 개념:**
1. **가상 메모리**: 물리 메모리보다 큰 주소 공간 제공
2. **페이징**: 메모리를 고정 크기(4KB) 페이지로 나누어 관리
3. **페이지 테이블**: 가상 주소 → 물리 주소 변환
4. **페이지 폴트**: 디스크에서 메모리로 페이지 로드 (느림!)
5. **TLB**: 주소 변환 속도를 높이는 캐시

**페이지 교체 알고리즘:**
- **FIFO**: 구현 간단하지만 효율 낮음
- **LRU**: 효율 높지만 구현 복잡
- **Clock**: LRU 근사, 효율과 구현 복잡도 균형

**실무 포인트:**
1. 페이지 폴트가 과도하면 성능 저하 (스래싱)
2. 메모리 모니터링: `free`, `vmstat`, `top`
3. Swap 사용은 메모리 부족 신호
4. JVM 힙 크기 적절히 설정
5. 컨테이너 메모리 제한 고려

**트레이드오프:**
- 페이지 크기 ↑ → 내부 단편화 ↑, 페이지 테이블 크기 ↓
- 페이지 크기 ↓ → 페이지 테이블 크기 ↑, 페이지 폴트 ↑
