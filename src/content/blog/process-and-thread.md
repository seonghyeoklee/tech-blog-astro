---
title: '프로세스와 스레드 - 운영체제 기초'
description: '프로세스와 스레드의 차이, 메모리 구조, 멀티스레딩의 장단점을 정리했습니다'
pubDate: 'Jan 05 2025'
tags: ['CS', 'OS']
---

백엔드 개발을 하다 보면 "스레드 풀 크기를 얼마로 설정해야 하나요?"라는 질문을 자주 받습니다. 이 질문에 제대로 답하려면 프로세스와 스레드가 무엇인지, 어떻게 다른지 알아야 합니다. 면접에서도 단골 질문이지만, 실무에서 동시성 문제를 다룰 때도 필수적인 개념입니다.

## 프로세스란

프로세스는 실행 중인 프로그램입니다. 디스크에 저장된 프로그램 파일을 메모리에 올려서 실행하면 프로세스가 됩니다.

운영체제는 각 프로세스에게 독립된 메모리 공간을 할당합니다. 이 메모리 공간은 크게 4가지 영역으로 나뉩니다.

```
┌─────────────────┐ 높은 주소
│      Stack      │ ← 지역 변수, 함수 호출 정보
├─────────────────┤
│        ↓        │
│                 │
│        ↑        │
├─────────────────┤
│      Heap       │ ← 동적 할당 메모리 (new, malloc)
├─────────────────┤
│      Data       │ ← 전역 변수, static 변수
├─────────────────┤
│      Code       │ ← 실행할 코드
└─────────────────┘ 낮은 주소
```

- **Code**: 실행할 명령어들이 저장됩니다. 읽기 전용입니다.
- **Data**: 전역 변수와 static 변수가 저장됩니다. 프로그램 시작 시 할당되고 종료 시 해제됩니다.
- **Heap**: 동적으로 할당되는 메모리입니다. Java의 new, C의 malloc이 여기에 할당됩니다.
- **Stack**: 함수 호출 시 생성되는 지역 변수, 매개변수, 리턴 주소가 저장됩니다.

각 프로세스는 이 메모리 공간을 독립적으로 가집니다. A 프로세스가 B 프로세스의 메모리에 직접 접근할 수 없습니다. 이게 프로세스 간 격리입니다.

## 스레드란

스레드는 프로세스 내에서 실행되는 흐름의 단위입니다. 하나의 프로세스는 최소 하나의 스레드를 가지고, 여러 스레드를 가질 수도 있습니다.

스레드의 핵심은 메모리 공유입니다. 같은 프로세스 내의 스레드들은 Code, Data, Heap 영역을 공유합니다. 각 스레드가 독립적으로 가지는 것은 Stack뿐입니다.

```
┌───────────────────────────────────────┐
│              프로세스                   │
│  ┌─────────────────────────────────┐  │
│  │    Code (공유)                   │  │
│  ├─────────────────────────────────┤  │
│  │    Data (공유)                   │  │
│  ├─────────────────────────────────┤  │
│  │    Heap (공유)                   │  │
│  ├─────────────────────────────────┤  │
│  │  Stack 1  │  Stack 2  │  Stack 3 │  │ ← 스레드별 독립
│  │ (스레드1) │ (스레드2) │ (스레드3) │  │
│  └─────────────────────────────────┘  │
└───────────────────────────────────────┘
```

스레드마다 독립적인 Stack을 가지는 이유는 함수 호출 흐름이 스레드마다 다르기 때문입니다. 스레드 1이 함수 A를 호출하는 동안 스레드 2는 함수 B를 호출할 수 있습니다.

## 프로세스 vs 스레드

| 구분 | 프로세스 | 스레드 |
|------|----------|--------|
| 메모리 | 독립적 | 공유 (Stack만 독립) |
| 생성 비용 | 높음 | 낮음 |
| 컨텍스트 스위칭 | 느림 | 빠름 |
| 통신 | IPC 필요 | 메모리 직접 공유 |
| 안정성 | 다른 프로세스에 영향 없음 | 한 스레드 문제가 전체에 영향 |

프로세스를 새로 만들면 메모리 공간 전체를 새로 할당해야 합니다. 운영체제 입장에서 비용이 큽니다. 스레드는 Stack만 새로 할당하면 되니까 훨씬 가볍습니다.

컨텍스트 스위칭도 마찬가지입니다. 프로세스 간 전환은 메모리 맵 전체를 교체해야 하지만, 스레드 간 전환은 Stack과 레지스터만 교체하면 됩니다.

## 멀티프로세스 vs 멀티스레드

웹 서버를 예로 들어보겠습니다. 요청이 동시에 100개 들어온다면 어떻게 처리할까요?

**멀티프로세스 방식 (Apache prefork)**

요청마다 새 프로세스를 생성합니다. 프로세스끼리 격리되어 있어서 한 프로세스가 죽어도 다른 프로세스에 영향이 없습니다. 하지만 프로세스 생성 비용이 크고, 메모리 사용량도 많습니다.

**멀티스레드 방식 (Tomcat)**

요청마다 새 스레드를 생성합니다. 스레드 생성 비용이 적고, 메모리를 공유하니까 효율적입니다. 하지만 하나의 스레드에서 문제가 생기면 전체 프로세스에 영향을 줄 수 있습니다. 또한 공유 메모리 접근 시 동기화 문제를 신경 써야 합니다.

```java
// 멀티스레드 환경에서 동기화 문제 예시
public class Counter {
    private int count = 0;  // 공유 자원

    public void increment() {
        count++;  // 이 연산은 원자적이지 않음
    }
}
```

count++는 단순해 보이지만 실제로는 읽기 → 증가 → 쓰기 3단계로 이루어집니다. 두 스레드가 동시에 실행하면 값이 꼬일 수 있습니다. 이런 상황을 Race Condition이라고 합니다.

## 스레드 풀

스레드를 매번 생성하고 삭제하는 것도 비용입니다. 그래서 실무에서는 스레드 풀을 사용합니다. 미리 일정 개수의 스레드를 만들어두고, 작업이 들어오면 유휴 스레드에 할당합니다.

```java
// Java 스레드 풀 예시
ExecutorService executor = Executors.newFixedThreadPool(10);

for (int i = 0; i < 100; i++) {
    executor.submit(() -> {
        // 작업 처리
    });
}
```

100개의 작업이 들어와도 스레드는 10개만 사용합니다. 작업이 끝난 스레드가 다음 작업을 가져갑니다.

스레드 풀 크기 설정은 상황에 따라 다릅니다.

- **CPU 바운드 작업**: CPU 코어 수 + 1 정도. 계산 작업이 주라면 스레드가 많아봐야 컨텍스트 스위칭 오버헤드만 증가합니다.
- **I/O 바운드 작업**: 코어 수보다 많이. DB 조회나 API 호출처럼 대기 시간이 긴 작업은 스레드가 많아야 CPU를 효율적으로 사용합니다.

## 정리

- 프로세스는 독립된 메모리 공간을 가지는 실행 단위입니다
- 스레드는 프로세스 내에서 메모리를 공유하는 실행 단위입니다
- 스레드는 Stack만 독립적이고, Code/Data/Heap은 공유합니다
- 멀티스레드는 효율적이지만 동기화 문제를 주의해야 합니다
- 실무에서는 스레드 풀을 사용하여 스레드 생성 비용을 줄입니다

다음 글에서는 컨텍스트 스위칭이 어떻게 동작하는지 다루겠습니다.
