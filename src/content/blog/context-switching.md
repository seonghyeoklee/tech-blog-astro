---
title: '컨텍스트 스위칭 - 프로세스 전환의 비용'
description: '컨텍스트 스위칭이 무엇이고 왜 비용이 발생하는지 정리했습니다'
pubDate: 'Jan 08 2025'
tags: ['CS', 'OS']
series: 'backend-cs-fundamentals'
seriesOrder: 3
---

스레드 풀 크기를 정할 때 "컨텍스트 스위칭 오버헤드를 고려해야 한다"는 말을 자주 듣습니다. 그런데 컨텍스트 스위칭이 정확히 뭐고, 왜 비용이 발생하는 걸까요? 이 개념을 제대로 이해하면 동시성 프로그래밍에서 더 나은 결정을 내릴 수 있습니다.

## 컨텍스트 스위칭이란

CPU는 한 번에 하나의 작업만 처리할 수 있습니다. 여러 프로세스가 동시에 실행되는 것처럼 보이는 건 CPU가 빠르게 전환하면서 조금씩 처리하기 때문입니다. 이 전환 과정을 컨텍스트 스위칭이라고 합니다.

프로세스 A를 실행하다가 프로세스 B로 전환하려면, A의 현재 상태를 저장하고 B의 이전 상태를 복원해야 합니다. 이 "상태"를 컨텍스트라고 부릅니다.

## 컨텍스트에 포함되는 것

CPU가 프로세스를 실행할 때 사용하는 정보들입니다.

```
┌─────────────────────────────┐
│         컨텍스트             │
├─────────────────────────────┤
│ Program Counter (PC)        │ ← 다음에 실행할 명령어 주소
│ Stack Pointer (SP)          │ ← 스택의 현재 위치
│ 범용 레지스터들              │ ← 연산 중간 결과
│ 프로세스 상태                │ ← 실행 중/대기 중/준비 등
│ 메모리 관리 정보             │ ← 페이지 테이블 등
└─────────────────────────────┘
```

이 정보들은 PCB(Process Control Block)에 저장됩니다. 운영체제가 각 프로세스마다 PCB를 관리합니다.

## 컨텍스트 스위칭 과정

```
시간 →

프로세스 A 실행 중
        │
        ▼
┌───────────────────┐
│ 1. 인터럽트 발생   │ (타이머, I/O 완료 등)
└───────────────────┘
        │
        ▼
┌───────────────────┐
│ 2. A 컨텍스트 저장 │ → PCB_A에 저장
└───────────────────┘
        │
        ▼
┌───────────────────┐
│ 3. 스케줄러 실행   │ → 다음 프로세스 선택
└───────────────────┘
        │
        ▼
┌───────────────────┐
│ 4. B 컨텍스트 복원 │ ← PCB_B에서 로드
└───────────────────┘
        │
        ▼
프로세스 B 실행 시작
```

1번부터 4번까지가 순수한 오버헤드입니다. 이 시간 동안 실제 작업은 전혀 진행되지 않습니다.

## 왜 비용이 발생하는가

컨텍스트 스위칭 비용은 두 가지로 나눌 수 있습니다.

**직접 비용**

레지스터 저장/복원, PCB 업데이트 등 전환 자체에 드는 시간입니다. 현대 CPU에서 수 마이크로초 정도입니다. 이것만 보면 별거 아닌 것 같습니다.

**간접 비용 (이게 더 큼)**

캐시 무효화가 진짜 문제입니다. CPU는 자주 쓰는 데이터를 캐시에 올려둡니다. 프로세스가 바뀌면 캐시에 있는 데이터가 대부분 쓸모없어집니다.

```
프로세스 A 실행 중:
┌─────────┐
│ L1 캐시 │ ← A의 데이터로 가득 참 (Cache Hot)
└─────────┘

컨텍스트 스위칭 후:
┌─────────┐
│ L1 캐시 │ ← A의 데이터가 있지만 B에겐 쓸모없음 (Cache Cold)
└─────────┘

프로세스 B가 데이터 접근:
→ 캐시 미스 → 메모리에서 다시 로드 (느림)
```

L1 캐시 접근은 1나노초 미만이지만, 메모리 접근은 100나노초 정도 걸립니다. 100배 차이입니다. 캐시가 다시 채워질 때까지 이런 패널티가 계속 발생합니다.

TLB(Translation Lookaside Buffer)도 마찬가지입니다. 가상 주소 → 물리 주소 변환 캐시인데, 프로세스가 바뀌면 무효화됩니다.

## 프로세스 vs 스레드 컨텍스트 스위칭

스레드 간 전환이 프로세스 간 전환보다 가볍습니다.

| 구분 | 프로세스 전환 | 스레드 전환 |
|------|--------------|------------|
| 레지스터 저장/복원 | O | O |
| 메모리 맵 교체 | O | X (같은 주소 공간) |
| TLB 플러시 | O | X |
| 캐시 영향 | 큼 | 상대적으로 작음 |

같은 프로세스 내의 스레드들은 메모리를 공유하기 때문에, 메모리 맵을 교체할 필요가 없습니다. TLB도 유지됩니다. 캐시도 공유 데이터가 있으면 어느 정도 활용할 수 있습니다.

## 컨텍스트 스위칭이 발생하는 상황

**1. 타임 슬라이스 만료**

운영체제는 각 프로세스에게 일정 시간(타임 슬라이스)만 CPU를 줍니다. 시간이 다 되면 강제로 전환합니다. 공정하게 CPU를 나눠 쓰기 위해서입니다.

**2. I/O 요청**

파일 읽기, 네트워크 요청 등 I/O 작업을 하면 프로세스는 대기 상태가 됩니다. CPU를 놀리지 않기 위해 다른 프로세스로 전환합니다.

**3. 우선순위 높은 프로세스 등장**

더 급한 작업이 들어오면 현재 작업을 중단하고 전환합니다.

## 실무에서 고려할 점

**스레드 수와 컨텍스트 스위칭**

스레드를 많이 만들면 컨텍스트 스위칭이 자주 발생합니다. CPU 코어가 4개인데 스레드가 400개면, 스위칭 오버헤드가 실제 작업 시간을 잡아먹습니다.

```java
// CPU 바운드 작업이라면
int threadCount = Runtime.getRuntime().availableProcessors() + 1;
ExecutorService executor = Executors.newFixedThreadPool(threadCount);
```

CPU 바운드 작업은 코어 수에 맞춰서. 스레드가 많아봐야 컨텍스트 스위칭만 늘어납니다.

**I/O 바운드는 다름**

I/O 대기 시간이 길면 스레드가 많아도 괜찮습니다. 어차피 I/O 대기 중에는 CPU를 안 쓰니까, 다른 스레드가 그 시간을 활용할 수 있습니다.

```java
// I/O 바운드 작업이라면
// 코어 수보다 많이 설정해도 됨
ExecutorService executor = Executors.newFixedThreadPool(50);
```

**비동기/논블로킹**

컨텍스트 스위칭을 줄이는 또 다른 방법은 비동기 프로그래밍입니다. 적은 스레드로 많은 요청을 처리할 수 있습니다. Node.js, Netty, WebFlux 같은 프레임워크가 이 방식입니다.

## 정리

- 컨텍스트 스위칭은 CPU가 프로세스/스레드를 전환할 때 발생합니다
- 직접 비용보다 캐시 무효화로 인한 간접 비용이 더 큽니다
- 스레드 전환이 프로세스 전환보다 가볍습니다
- CPU 바운드 작업은 스레드 수를 코어 수에 맞추는 게 좋습니다
- I/O 바운드 작업은 스레드를 더 많이 써도 괜찮습니다
